# 🧠 Decoratorパターン 小テスト（全10問・選択式）

---

## Q1. Decoratorパターンの主な目的は？

- A) クラス間の継承を制限するため  
- **B) クラスの機能を動的に追加・変更できるようにする（例：攻撃に炎属性を追加する）**  
- C) クラスの名前を変更するため  
- D) クラスを抽象化するためだけに使う  

---

## Q2. Decoratorパターンで「元の機能」を提供する役割はどれ？

- **A) ConcreteComponent（例：BasicAttackなど基本の処理を持つクラス）**  
- B) Strategy  
- C) Interface  
- D) BaseState  

---

## Q3. DecoratorクラスがComponentと同じインターフェースを実装する理由は？

- A) 名前を揃えるため  
- **B) 同じ型で扱えるようにして、元のクラスと装飾クラスを入れ替え可能にする（例：Attackクラスにexecute関数を持たせる）**  
- C) オーバーロードを防ぐため  
- D) テンプレート化するため  

---

## Q4. Decoratorの設計が適しているゲーム内の例は？

- A) 変数のスコープを制御する  
- B) ボスの体力を増やすだけの処理  
- **C) 攻撃に属性やエフェクトを追加したいとき（例：毒攻撃や氷攻撃の追加）**  
- D) 配列をループで処理するとき  

---

## Q5. Decoratorパターンの利点として正しくないものは？

- A) 継承に比べて柔軟に拡張できる  
- **B) 全ての機能追加を1クラスにまとめられる（※これはクラス肥大化の原因）**  
- C) 実行時に機能の組み合わせが変更できる  
- D) 開放/閉鎖原則（OCP）に適合する  

---

## Q6. 複数のDecoratorを組み合わせるときの実装方法で正しいのは？

- A) 全て継承でつなぐ  
- **B) Decoratorをラップするようにネストして使う（例：new Ice(new Poison(new Fire(new Basic())))）**  
- C) 複数のクラスを一斉に継承する  
- D) テンプレートで制御する  

---

## Q7. 【やや難問】Decoratorの副作用に注意が必要な場面とは？

- A) アニメーション処理  
- B) 入力処理のタイミング  
- **C) 同じメソッドが何度も呼ばれる可能性があるため、内部状態や副作用に注意すること**  
- D) 変数名の重複  

---

## Q8. 【やや難問】Decoratorを使うことで処理の順番が重要になる理由は？

- A) 継承の順番で処理が決まるため  
- B) スレッドセーフにする必要があるため  
- **C) 実行時に呼ばれる順序がネスト順に依存するため（例：火→毒→氷 と 氷→毒→火では出力が変わる）**  
- D) コンパイルエラーが出るから  

---

## Q9. StrategyパターンとDecoratorパターンの主な違いは？

- A) 両方ともまったく同じ使い方  
- **B) Strategyは「やり方を切り替える」、Decoratorは「元の機能に追加する」（例：攻撃方法を選ぶ vs 効果を追加）**  
- C) 両方ともテンプレートでしか実装できない  
- D) 両方とも状態パターンに置き換えられる  

---

## Q10. Decoratorパターンが不適切な場面は？

- A) UIのパーツに装飾を追加する  
- B) 攻撃効果を複数組み合わせたいとき  
- **C) 状態管理とその遷移に応じて振る舞いを変えるとき（これはStateパターンの役割）**  
- D) 処理を構成で分けたいとき  

---