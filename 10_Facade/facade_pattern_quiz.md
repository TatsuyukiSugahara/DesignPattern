
# 🧠 ファサードパターン 小テスト（全10問・選択式）

---

## Q1. ファサードパターンの目的として正しいのは？

- A) クラスを小さく分割すること  
- **B) 複雑な処理を単純な窓口でまとめる（例：GameSystem::startGame() でシーンロード＋BGM再生＋UI表示）**  
- C) 状態ごとに処理を切り替える  
- D) プレイヤーの入力を無効にする  

---

## Q2. ファサードが提供するのは？

- A) サブシステムへの直接アクセス方法  
- **B) 外部向けのシンプルなインターフェース（例：Pause() がBGM停止とUI表示をまとめて呼ぶ）**  
- C) Observerの通知機構  
- D) Strategyの切り替え方法  

---

## Q3. ファサードクラス自身が直接すべての処理を行うべき？

- A) はい、すべての機能を実装するべき  
- **B) いいえ、内部のサブクラスに処理を委ねる（例：AudioManager, SceneLoaderなどを持つ）**  
- C) ユーザーが直接呼び出すべき  
- D) 外部から自由に操作できるようにする  

---

## Q4. ゲームの開始処理において、Facadeを使うと？

- A) 一つずつ個別に呼び出す必要がある  
- B) メニューとBGMを同時に処理できない  
- **C) GameSystem::startGame() など1つの関数で複数の機能を呼べるようになる（例：ロード＋BGM＋UI）**  
- D) 実行速度が遅くなる  

---

## Q5. ファサードが不要なケースはどれ？

- A) 外部とのやり取りが簡単な場合  
- B) 内部が極めて単純で直接呼び出しても支障がない  
- **C) 外部とのやり取りが簡単な場合で内部が極めて単純で直接呼び出しても支障がない場合**  
- D) 処理を分割して管理したいとき  

---

## Q6. ゲームの「セーブ機能」にFacadeを使う利点は？

- A) ユーザーに保存先を選ばせることができる  
- **B) save() 関数を呼ぶだけで、データ取得→保存→通知表示までまとめて処理できる（例：SaveSystem::save()）**  
- C) Observerで通知ができる  
- D) 状態を保存するため  

---

## Q7. 他のパターンと比較した時のFacadeの特徴は？

- A) 処理の切り替えを行う  
- B) 状態に応じて動作を変更する  
- **C) 内部構造を隠して、使いやすい1つの窓口を提供する（例：UIManagerやAudioManagerの内部を意識させない）**  
- D) 全てのクラスを継承する構造を作る  

---

## Q8. 【やや難問】Facadeパターンで「依存関係を減らせる」理由は？

- A) すべてのクラスがファサードを継承するから  
- **B) 外部がサブシステムの詳細を知らなくて済む（例：GameSystem を使えば AudioManager の実装を知らなくても使える）**  
- C) クラスの数が減るから  
- D) 直接的に処理を書くから  

---

## Q9. 【やや難問】次の設計で変更に強いのはどれ？

- A) main関数で毎回 SceneLoader, AudioManager, UIManager を個別に操作  
- B) 各クラスをnewして直接呼び出す設計  
- **C) GameSystem::startGame() を作って内部の各操作をまとめる（例：GameSystemが内部をカプセル化）**  
- D) 各クラスに全て同じ名前の関数を付ける  

---

## Q10. ファサードの構造にもっとも近い例はどれ？

- A) 複数のAPIを個別に使ってデータを処理  
- **B) 「テレビのリモコン」のようにボタン1つで複数の処理をまとめて呼ぶ（例：電源ボタン→画面ON＋スピーカーON）**  
- C) 通知イベントを監視するシステム  
- D) 状態が変化することで処理が分かれるシステム  

---
